// Generated by Haxe 4.0.0-rc.4+672c3f246
(function ($global) { "use strict";
var $estr = function() { return js_Boot.__string_rec(this,''); },$hxEnums = $hxEnums || {},$_;
class EReg {
	constructor(r,opt) {
		this.r = new RegExp(r,opt.split("u").join(""));
	}
	match(s) {
		if(this.r.global) {
			this.r.lastIndex = 0;
		}
		this.r.m = this.r.exec(s);
		this.r.s = s;
		return this.r.m != null;
	}
	matched(n) {
		if(this.r.m != null && n >= 0 && n < this.r.m.length) {
			return this.r.m[n];
		} else {
			throw new js__$Boot_HaxeError("EReg::matched");
		}
	}
}
EReg.__name__ = true;
class HxOverrides {
	static cca(s,index) {
		var x = s.charCodeAt(index);
		if(x != x) {
			return undefined;
		}
		return x;
	}
	static substr(s,pos,len) {
		if(len == null) {
			len = s.length;
		} else if(len < 0) {
			if(pos == 0) {
				len = s.length + len;
			} else {
				return "";
			}
		}
		return s.substr(pos,len);
	}
	static remove(a,obj) {
		var i = a.indexOf(obj);
		if(i == -1) {
			return false;
		}
		a.splice(i,1);
		return true;
	}
	static iter(a) {
		return { cur : 0, arr : a, hasNext : function() {
			return this.cur < this.arr.length;
		}, next : function() {
			return this.arr[this.cur++];
		}};
	}
}
HxOverrides.__name__ = true;
class Lambda {
	static count(it,pred) {
		var n = 0;
		if(pred == null) {
			var _ = $getIterator(it);
			while(_.hasNext()) {
				var _1 = _.next();
				++n;
			}
		} else {
			var x = $getIterator(it);
			while(x.hasNext()) {
				var x1 = x.next();
				if(pred(x1)) {
					++n;
				}
			}
		}
		return n;
	}
}
Lambda.__name__ = true;
Math.__name__ = true;
class Reflect {
	static fields(o) {
		var a = [];
		if(o != null) {
			var hasOwnProperty = Object.prototype.hasOwnProperty;
			for( var f in o ) {
			if(f != "__id__" && f != "hx__closures__" && hasOwnProperty.call(o,f)) {
				a.push(f);
			}
			}
		}
		return a;
	}
}
Reflect.__name__ = true;
class Std {
	static string(s) {
		return js_Boot.__string_rec(s,"");
	}
	static parseInt(x) {
		var v = parseInt(x, x && x[0]=="0" && (x[1]=="x" || x[1]=="X") ? 16 : 10);
		if(isNaN(v)) {
			return null;
		}
		return v;
	}
}
Std.__name__ = true;
class StringTools {
	static isSpace(s,pos) {
		var c = HxOverrides.cca(s,pos);
		if(!(c > 8 && c < 14)) {
			return c == 32;
		} else {
			return true;
		}
	}
	static ltrim(s) {
		var l = s.length;
		var r = 0;
		while(r < l && StringTools.isSpace(s,r)) ++r;
		if(r > 0) {
			return HxOverrides.substr(s,r,l - r);
		} else {
			return s;
		}
	}
	static rtrim(s) {
		var l = s.length;
		var r = 0;
		while(r < l && StringTools.isSpace(s,l - r - 1)) ++r;
		if(r > 0) {
			return HxOverrides.substr(s,0,l - r);
		} else {
			return s;
		}
	}
	static trim(s) {
		return StringTools.ltrim(StringTools.rtrim(s));
	}
	static replace(s,sub,by) {
		return s.split(sub).join(by);
	}
}
StringTools.__name__ = true;
class Sys {
	static environment() {
		var m = new haxe_ds_StringMap();
		var _g = 0;
		var _g1 = Reflect.fields(process.env);
		while(_g < _g1.length) {
			var key = _g1[_g];
			++_g;
			var v = process.env[key];
			if(__map_reserved[key] != null) {
				m.setReserved(key,v);
			} else {
				m.h[key] = v;
			}
		}
		return m;
	}
	static systemName() {
		var _g = process.platform;
		switch(_g) {
		case "darwin":
			return "Mac";
		case "freebsd":
			return "BSD";
		case "linux":
			return "Linux";
		case "win32":
			return "Windows";
		default:
			var other = _g;
			return other;
		}
	}
}
Sys.__name__ = true;
class haxe_io_Output {
}
haxe_io_Output.__name__ = true;
class _$Sys_FileOutput extends haxe_io_Output {
	constructor(fd) {
		super();
		this.fd = fd;
	}
	writeByte(c) {
		js_node_Fs.writeSync(this.fd,String.fromCodePoint(c));
	}
	writeBytes(s,pos,len) {
		var data = s.b;
		return js_node_Fs.writeSync(this.fd,js_node_buffer_Buffer.from(data.buffer,data.byteOffset,s.length),pos,len);
	}
	writeString(s,encoding) {
		js_node_Fs.writeSync(this.fd,s);
	}
	flush() {
		js_node_Fs.fsyncSync(this.fd);
	}
	close() {
		js_node_Fs.closeSync(this.fd);
	}
}
_$Sys_FileOutput.__name__ = true;
class haxe_io_Input {
}
haxe_io_Input.__name__ = true;
class _$Sys_FileInput extends haxe_io_Input {
	constructor(fd) {
		super();
		this.fd = fd;
	}
	readByte() {
		var buf = new js_node_buffer_Buffer(1);
		try {
			js_node_Fs.readSync(this.fd,buf,0,1,null);
		} catch( e ) {
			var e1 = ((e) instanceof js__$Boot_HaxeError) ? e.val : e;
			if(e1.code == "EOF") {
				throw new js__$Boot_HaxeError(new haxe_io_Eof());
			} else {
				throw new js__$Boot_HaxeError(haxe_io_Error.Custom(e1));
			}
		}
		return buf[0];
	}
	readBytes(s,pos,len) {
		var data = s.b;
		var buf = js_node_buffer_Buffer.from(data.buffer,data.byteOffset,s.length);
		try {
			return js_node_Fs.readSync(this.fd,buf,pos,len,null);
		} catch( e ) {
			var e1 = ((e) instanceof js__$Boot_HaxeError) ? e.val : e;
			if(e1.code == "EOF") {
				throw new js__$Boot_HaxeError(new haxe_io_Eof());
			} else {
				throw new js__$Boot_HaxeError(haxe_io_Error.Custom(e1));
			}
		}
	}
	close() {
		js_node_Fs.closeSync(this.fd);
	}
}
_$Sys_FileInput.__name__ = true;
var vscode_debugAdapter_DebugSession = require("vscode-debugadapter").DebugSession;
class vshaxeDebug_BaseAdapter extends vscode_debugAdapter_DebugSession {
	constructor() {
		super();
		this.terminated = false;
	}
	createContext(program) {
		throw new js__$Boot_HaxeError("not implemented");
	}
	getLaunchCommand(context,response,args) {
		throw new js__$Boot_HaxeError("not implemented");
	}
	getAttachCommand(context,response,args) {
		throw new js__$Boot_HaxeError("not implemented");
	}
	dispatchRequest(request) {
		this.traceJson(request);
		super.dispatchRequest(request);
	}
	sendResponse(response) {
		haxe_Log.trace("sendResponse: " + Std.string(response),{ fileName : "src/vshaxeDebug/BaseAdapter.hx", lineNumber : 43, className : "vshaxeDebug.BaseAdapter", methodName : "sendResponse"});
		super.sendResponse(response);
	}
	initializeRequest(response,args) {
		response.body.supportsConfigurationDoneRequest = true;
		response.body.supportsEvaluateForHovers = true;
		response.body.supportsStepBack = false;
		this.sendResponse(response);
	}
	launchRequest(response,args) {
		var customArgs = args;
		this.context = this.createContext(customArgs.program);
		this.debugger = this.context.debugger;
		this.parser = this.context.debugger.parser;
		this.cmd = this.context.debugger.commandBuilder;
		if(customArgs.receiveAdapterOutput != null && customArgs.receiveAdapterOutput) {
			this.redirectTraceToDebugConsole(this.context);
		}
		var launchCommand = this.getLaunchCommand(this.context,response,customArgs);
		launchCommand.execute();
	}
	attachRequest(response,args) {
		var customArgs = args;
		this.context = this.createContext(customArgs.program);
		this.debugger = this.context.debugger;
		this.parser = this.context.debugger.parser;
		this.cmd = this.context.debugger.commandBuilder;
		if(customArgs.receiveAdapterOutput != null && customArgs.receiveAdapterOutput) {
			this.redirectTraceToDebugConsole(this.context);
		}
		var maybeAttachCommand = this.getAttachCommand(this.context,response,customArgs);
		if(maybeAttachCommand._hx_index == 0) {
			var attachCommand = maybeAttachCommand.v;
			attachCommand.execute();
		} else {
			throw new js__$Boot_HaxeError("adapter doesn't support attach");
		}
	}
	setBreakPointsRequest(response,args) {
		var command = new vshaxeDebug_commands_SetBreakpoints(this.context,response,args);
		command.execute();
	}
	configurationDoneRequest(response,args) {
		this.debugger.queueSend(this.cmd.continueCommand());
		this.context.onEvent(vshaxeDebug_StateControlEvent.Continue);
		this.sendResponse(response);
	}
	threadsRequest(response) {
		response.body = { threads : [new vscode_debugAdapter_Thread(1,"thread 1")]};
		this.sendResponse(response);
	}
	stackTraceRequest(response,args) {
		var cmd = new vshaxeDebug_commands_StackTrace(this.context,response,args);
		cmd.execute();
	}
	scopesRequest(response,args) {
		var frameId = args.frameId;
		var scopes = [new vscode_debugAdapter_Scope("Locals",this.context.variableHandles.create("locals_" + frameId),false),new vscode_debugAdapter_Scope("Members",this.context.variableHandles.create("members_" + frameId),false),new vscode_debugAdapter_Scope("Globals",this.context.variableHandles.create("globals_" + frameId),true)];
		response.body = { scopes : scopes};
		this.sendResponse(response);
	}
	variablesRequest(response,args) {
		var command = new vshaxeDebug_commands_Variables(this.context,response,args);
		command.execute();
	}
	evaluateRequest(response,args) {
		if(this.context == null) {
			this.sendResponse(response);
			return;
		}
		var _g = this.context.debuggerState;
		if(_g._hx_index == 3) {
			var _g2 = _g.currentFrame;
			var _g1 = _g.frames;
			var command = new vshaxeDebug_commands_Evaluate(this.context,response,args);
			command.execute();
		} else {
			this.sendResponse(response);
		}
	}
	stepInRequest(response,args) {
		this.stepRequest(this.cmd.stepIn(),response);
	}
	stepOutRequest(response,args) {
		this.stepRequest(this.cmd.stepOut(),response);
	}
	nextRequest(response,args) {
		this.stepRequest(this.cmd.next(),response);
	}
	stepRequest(cmd,response) {
		var _gthis = this;
		this.debugger.queueSend(cmd,function(_) {
			_gthis.sendResponse(response);
			_gthis.sendEvent(new vscode_debugAdapter_StoppedEvent("step",1));
			return true;
		});
	}
	continueRequest(response,args) {
		this.debugger.queueSend(this.cmd.continueCommand());
		this.sendResponse(response);
		this.context.onEvent(vshaxeDebug_StateControlEvent.Continue);
	}
	pauseRequest(response,args) {
		var _gthis = this;
		this.debugger.queueSend(this.cmd.pause(),function(_) {
			_gthis.sendResponse(response);
			_gthis.context.onEvent(vshaxeDebug_StateControlEvent.Stop("pause"));
			return true;
		});
	}
	disconnectRequest(response,args) {
		var _gthis = this;
		if(this.terminated) {
			this.sendResponse(response);
			return;
		}
		this.debugger.queueSend(this.cmd.disconnect(),function(_) {
			_gthis.sendResponse(response);
			return true;
		});
	}
	onPromptGot(lines) {
		switch(this.context.debuggerState._hx_index) {
		case 0:
			if(this.parser.isGreetingMatched(lines)) {
				this.context.onEvent(vshaxeDebug_StateControlEvent.GreetingReceived);
			} else {
				haxe_Log.trace("Start FAILED: [" + Std.string(lines) + "]",{ fileName : "src/vshaxeDebug/BaseAdapter.hx", lineNumber : 192, className : "vshaxeDebug.BaseAdapter", methodName : "onPromptGot"});
			}
			break;
		case 2:
			if(this.parser.isStopOnBreakpointMatched(lines)) {
				this.context.onEvent(vshaxeDebug_StateControlEvent.Stop("breakpoint"));
			} else if(this.parser.isStopOnExceptionMatched(lines)) {
				this.context.onEvent(vshaxeDebug_StateControlEvent.Stop("exception"));
			}
			break;
		default:
		}
	}
	allOutputReceiver(string) {
		var proceed = false;
		if(this.parser.isExitMatched(string)) {
			var event = new vscode_debugAdapter_TerminatedEvent(false);
			this.traceJson(event);
			this.sendEvent(event);
			this.terminated = true;
			this.debugger.stop();
			return true;
		}
		if(this.context.debuggerState._hx_index == 2) {
			var lines = this.parser.getTraces(string);
			var _g = 0;
			while(_g < lines.length) {
				var line = lines[_g];
				++_g;
				this.context.sendToOutput(line);
				proceed = true;
			}
		}
		return proceed;
	}
	traceJson(value) {
		haxe_Log.trace(JSON.stringify(value),{ fileName : "src/vshaxeDebug/BaseAdapter.hx", lineNumber : 228, className : "vshaxeDebug.BaseAdapter", methodName : "traceJson"});
	}
	redirectTraceToDebugConsole(context) {
		haxe_Log.trace = function(v,i) {
			context.sendToOutput("DebugAdapter: " + v,"stdout");
		};
	}
}
vshaxeDebug_BaseAdapter.__name__ = true;
class fdbAdapter_Adapter extends vshaxeDebug_BaseAdapter {
	constructor() {
		super();
	}
	getLaunchCommand(context,response,args) {
		return new fdbAdapter_commands_Launch(context,response,args);
	}
	getAttachCommand(context,response,args) {
		var command = new fdbAdapter_commands_Attach(context,response,args);
		return haxe_ds_Option.Some(command);
	}
	createContext(program) {
		var scriptPath = __dirname;
		var commandBuilder = new fdbAdapter_CommandBuilder();
		var eolSign = vshaxeDebug_PlatformParameters.getEndOfLineSign();
		var parser = new fdbAdapter_Parser(eolSign);
		var cliAdapterConfig = { cmd : this.resolveJavaPath(), cmdParams : ["-Duser.language=en","-jar","" + scriptPath + "/../fdb/fdb.jar"], onPromptGot : $bind(this,this.onPromptGot), onError : function(error) {
			return "Could not start fdb. Make sure that PATH contains the Java executable or JAVA_HOME is set correctly.";
		}, allOutputReceiver : $bind(this,this.allOutputReceiver), commandBuilder : commandBuilder, parser : parser};
		this.debugger = new vshaxeDebug_CLIAdapter(cliAdapterConfig);
		this.debugger.start();
		return new vshaxeDebug_Context(this,this.debugger);
	}
	resolveJavaPath() {
		var path = "java";
		var javaHome = process.env["JAVA_HOME"];
		if(javaHome != null) {
			path = haxe_io_Path.join([javaHome,"bin/java"]);
		}
		return path;
	}
	static main() {
		fdbAdapter_Adapter.setupTrace();
		vscode_debugAdapter_DebugSession.run(fdbAdapter_Adapter);
	}
	static setupTrace() {
		fdbAdapter_Adapter.logPath = __dirname + "/../fdb_log.txt";
		js_node_Fs.writeFile(fdbAdapter_Adapter.logPath,"","utf8",function(e) {
		});
		haxe_Log.trace = function(v,i) {
			var r = [Std.string(v)];
			fdbAdapter_Adapter.Log({ type : "INFO", message : r.join(" ")});
		};
	}
	static Log(input) {
		js_node_Fs.appendFile(fdbAdapter_Adapter.logPath,JSON.stringify(input) + "\n","utf8",function(e) {
		});
	}
}
fdbAdapter_Adapter.__name__ = true;
class fdbAdapter_CommandBuilder {
	constructor() {
	}
	launch() {
		return "run";
	}
	frameUp() {
		return "up";
	}
	frameDown() {
		return "down";
	}
	stepIn() {
		return "step";
	}
	stepOut() {
		return "finish";
	}
	next() {
		return "next";
	}
	continueCommand() {
		return "continue";
	}
	pause() {
		return "\ny";
	}
	stackTrace() {
		return "bt";
	}
	addBreakpoint(fileName,filePath,line) {
		return "break " + fileName + ":" + line;
	}
	removeBreakpoint(fileName,filePath,line) {
		return "clear " + fileName + ":" + line;
	}
	printLocalVariables() {
		return "info locals";
	}
	printFunctionArguments() {
		return "info arguments";
	}
	printGlobalVariables() {
		return "info global";
	}
	printObjectProperties(objectName) {
		return "print " + objectName + ".";
	}
	printMembers() {
		return "print this.";
	}
	showFiles() {
		return "show files";
	}
	evaluate(expr) {
		return "print " + expr;
	}
	disconnect() {
		return "kill\ny\nquit";
	}
}
fdbAdapter_CommandBuilder.__name__ = true;
class fdbAdapter_Parser {
	constructor(eolSign) {
		this.prompt = "(fdb) ";
		this.promptLength = this.prompt.length;
		this.eolSign = eolSign;
	}
	parseFunctionArguments(lines) {
		return this.parseVariables(lines);
	}
	parseGlobalVariables(lines) {
		return this.parseVariables(lines);
	}
	parseLocalVariables(lines) {
		return this.parseVariables(lines);
	}
	parseMembers(lines) {
		lines.shift();
		return this.parseVariables(lines);
	}
	parseObjectProperties(lines) {
		lines.shift();
		return this.parseVariables(lines);
	}
	parseEvaluate(lines) {
		var variables = this.parseVariables(lines);
		haxe_Log.trace(variables,{ fileName : "src/fdbAdapter/Parser.hx", lineNumber : 39, className : "fdbAdapter.Parser", methodName : "parseEvaluate"});
		if(variables.length > 0) {
			return haxe_ds_Option.Some(variables[0]);
		} else {
			return haxe_ds_Option.None;
		}
	}
	parseStackTrace(lines,pathProvider) {
		var maybeAddSource = function(frame,name) {
			if(name != "<null>") {
				frame.source = { name : name, path : pathProvider(name)};
			}
		};
		var result = [];
		var rMethod = new EReg("#([0-9]+)\\s+this = \\[Object [0-9]+, class='(.+)'\\]\\.(.+)\\(.*\\) at (.*):([0-9]+).*","");
		var anonFunction = new EReg("#([0-9]+)\\s+this = \\[Function [0-9]+, name='(.*)'\\]\\.([a-zA-Z0-9/\\$<>]+).*\\) at (.*):([0-9]+).*","");
		var globalCall = new EReg("#([0-9]+)\\s+(.*)\\(\\) at (.*):([0-9]+)","");
		var _g = 0;
		while(_g < lines.length) {
			var l = lines[_g];
			++_g;
			if(rMethod.match(l)) {
				var frame1 = { id : Std.parseInt(rMethod.matched(1)), name : rMethod.matched(2) + "." + rMethod.matched(3), line : Std.parseInt(rMethod.matched(5)), column : 0};
				maybeAddSource(frame1,rMethod.matched(4));
				result.push(frame1);
			} else if(anonFunction.match(l)) {
				var frame2 = { id : Std.parseInt(anonFunction.matched(1)), name : anonFunction.matched(2) + "." + anonFunction.matched(3), line : Std.parseInt(anonFunction.matched(5)), column : 0};
				maybeAddSource(frame2,anonFunction.matched(4));
				result.push(frame2);
			} else if(globalCall.match(l)) {
				result.push({ id : Std.parseInt(globalCall.matched(1)), name : globalCall.matched(2), line : Std.parseInt(globalCall.matched(4)), column : 0});
			}
		}
		return result;
	}
	parseAddBreakpoint(lines) {
		var result = haxe_ds_Option.None;
		var breakpointData = lines[0];
		var r = new EReg("Breakpoint ([0-9]+).*: file ([0-9A-Za-z\\.]+), line ([0-9]+)","");
		if(r.match(breakpointData)) {
			result = haxe_ds_Option.Some({ id : Std.parseInt(r.matched(1)), fileName : r.matched(2), line : Std.parseInt(r.matched(3))});
		}
		return result;
	}
	parseShowFiles(lines) {
		var result = [];
		var rRow = new EReg("^([0-9]+) (.+), ([a-zA-Z0-9:.]+)$","");
		var _g = 0;
		while(_g < lines.length) {
			var l = lines[_g];
			++_g;
			if(rRow.match(l)) {
				result.push({ name : rRow.matched(3), path : rRow.matched(2)});
			}
		}
		return result;
	}
	getLines(rawInput) {
		return rawInput.split(this.eolSign);
	}
	getLinesExceptPrompt(rawInput) {
		var withoutPrompt = rawInput.substring(0,rawInput.length - this.promptLength);
		return this.getLines(withoutPrompt);
	}
	getTraces(rawInput) {
		var result = [];
		var lines = this.getLines(rawInput);
		var traceR = new EReg("\\[trace\\](.*)","");
		var _g = 0;
		while(_g < lines.length) {
			var line = lines[_g];
			++_g;
			if(traceR.match(line)) {
				result.push(line);
			}
		}
		return result;
	}
	isPromptMatched(rawInput) {
		return HxOverrides.substr(rawInput,-this.promptLength,null) == this.prompt;
	}
	isExitMatched(rawInput) {
		var exitR = new EReg("\\[UnloadSWF\\]","");
		return exitR.match(rawInput);
	}
	isGreetingMatched(lines) {
		var firstLine = lines[0];
		if(firstLine != null) {
			return HxOverrides.substr(firstLine,0,5) == "Adobe";
		} else {
			return false;
		}
	}
	isStopOnBreakpointMatched(lines) {
		var _g = 0;
		while(_g < lines.length) {
			var line = lines[_g];
			++_g;
			var r = new EReg("Breakpoint ([0-9]+),(.*) (.+).hx:([0-9]+)","");
			if(r.match(line)) {
				return true;
			}
		}
		return false;
	}
	isStopOnExceptionMatched(lines) {
		var _g = 0;
		while(_g < lines.length) {
			var line = lines[_g];
			++_g;
			var r = new EReg("^\\[Fault\\].*","");
			if(r.match(line)) {
				return true;
			}
		}
		return false;
	}
	parseVariables(lines) {
		var rVar = new EReg("^(.*) = (.*)$","");
		var result = [];
		var _g = 0;
		while(_g < lines.length) {
			var line = lines[_g];
			++_g;
			if(rVar.match(line)) {
				var name = StringTools.trim(rVar.matched(1));
				var value = rVar.matched(2);
				var type = this.detectExpressionType(value);
				result.push({ name : name, type : type, value : value});
			}
		}
		return result;
	}
	detectExpressionType(expr) {
		var rObjectType = new EReg("^\\[Object (\\d+),","");
		var rIntType = new EReg("^\\d+ \\(0\\x\\d+\\)","");
		var rFloatType = new EReg("^\\d+\\.\\d+$","");
		var rStringType = new EReg("^[\\\\\"].*[\\\\\"]$","");
		var rBoolType = new EReg("^[t|f]\\S+$","");
		if(rObjectType.match(expr)) {
			var objectId = Std.parseInt(rObjectType.matched(1));
			return vshaxeDebug_VariableType.Object(objectId);
		} else if(rIntType.match(expr)) {
			return vshaxeDebug_VariableType.Simple("Int");
		} else if(rFloatType.match(expr)) {
			return vshaxeDebug_VariableType.Simple("Float");
		} else if(rStringType.match(expr)) {
			return vshaxeDebug_VariableType.Simple("String");
		} else if(rBoolType.match(expr)) {
			return vshaxeDebug_VariableType.Simple("Bool");
		} else {
			return vshaxeDebug_VariableType.Simple("Unknown");
		}
	}
}
fdbAdapter_Parser.__name__ = true;
class vshaxeDebug_commands_BaseCommand {
	constructor(context,response,args) {
		if(vshaxeDebug_commands_BaseCommand._hx_skip_constructor) {
			return;
		}
		this._hx_constructor(context,response,args);
	}
	_hx_constructor(context,response,args) {
		this.context = context;
		this.debugger = context.debugger;
		this.response = response;
		this.args = args;
		this.cmd = this.debugger.commandBuilder;
		this.parser = this.debugger.parser;
	}
	execute() {
	}
}
vshaxeDebug_commands_BaseCommand.__name__ = true;
class fdbAdapter_commands_Attach extends vshaxeDebug_commands_BaseCommand {
	constructor(context,response,args) {
		super(context,response,args);
	}
	execute() {
		this.debugger.queueSend("run",function(_) {
			return true;
		});
		this.context.sendToOutput("waiting..","stdout");
	}
}
fdbAdapter_commands_Attach.__name__ = true;
class fdbAdapter_commands_Launch extends vshaxeDebug_commands_BaseCommand {
	constructor(context,response,args) {
		super(context,response,args);
	}
	execute() {
		var program = this.args.program;
		var _gthis = this;
		if(!vshaxeDebug_PathUtils.isAbsolutePath(program)) {
			if(!vshaxeDebug_PathUtils.isOnPath(program)) {
				this.context.sendError(this.response,"Cannot find runtime " + program + " on PATH.");
				this.context.protocol.sendResponse(this.response);
				return;
			}
		} else if(!js_node_Fs.existsSync(program)) {
			this.response.success = false;
			this.response.message = "Cannot find " + program;
			this.context.protocol.sendResponse(this.response);
			return;
		}
		this.debugger.queueSend(this.cmd.launch(),$bind(this,this.processResult));
		var command = Sys.systemName() == "Mac" ? "open \"" + program + "\"" : "\"" + program + "\"";
		js_node_ChildProcess.exec(command,function(error,_,_1) {
			if(error != null) {
				_gthis.context.sendToOutput(Std.string(error));
			}
		});
		this.context.sendToOutput("running " + program,"stdout");
	}
	processResult(lines) {
		var matchingOutputLine = lines[lines.length - 1];
		haxe_Log.trace("Launch: " + Std.string(lines),{ fileName : "src/fdbAdapter/commands/Launch.hx", lineNumber : 37, className : "fdbAdapter.commands.Launch", methodName : "processResult"});
		var _g = 0;
		while(_g < lines.length) {
			var line = lines[_g];
			++_g;
			if(this.matchSWFConnected(line)) {
				this.context.protocol.sendResponse(this.response);
				this.context.sendToOutput("launch success","stdout");
				return true;
			}
		}
		return false;
	}
	matchSWFConnected(data) {
		if(data == null) {
			return false;
		} else {
			return HxOverrides.substr(data,0,5) == "[SWF]";
		}
	}
}
fdbAdapter_commands_Launch.__name__ = true;
class haxe_Log {
	static formatOutput(v,infos) {
		var str = Std.string(v);
		if(infos == null) {
			return str;
		}
		var pstr = infos.fileName + ":" + infos.lineNumber;
		if(infos.customParams != null) {
			var _g = 0;
			var _g1 = infos.customParams;
			while(_g < _g1.length) {
				var v1 = _g1[_g];
				++_g;
				str += ", " + Std.string(v1);
			}
		}
		return pstr + ": " + str;
	}
	static trace(v,infos) {
		var str = haxe_Log.formatOutput(v,infos);
		if(typeof(console) != "undefined" && console.log != null) {
			console.log(str);
		}
	}
}
haxe_Log.__name__ = true;
class haxe_ds_IntMap {
	constructor() {
		this.h = { };
	}
	remove(key) {
		if(!this.h.hasOwnProperty(key)) {
			return false;
		}
		delete(this.h[key]);
		return true;
	}
	keys() {
		var a = [];
		for( var key in this.h ) this.h.hasOwnProperty(key) ? a.push(key | 0) : null;
		return HxOverrides.iter(a);
	}
	iterator() {
		return { ref : this.h, it : this.keys(), hasNext : function() {
			return this.it.hasNext();
		}, next : function() {
			var i = this.it.next();
			return this.ref[i];
		}};
	}
}
haxe_ds_IntMap.__name__ = true;
var haxe_ds_Option = $hxEnums["haxe.ds.Option"] = { __ename__ : true, __constructs__ : ["Some","None"]
	,Some: ($_=function(v) { return {_hx_index:0,v:v,__enum__:"haxe.ds.Option",toString:$estr}; },$_.__params__ = ["v"],$_)
	,None: {_hx_index:1,__enum__:"haxe.ds.Option",toString:$estr}
};
class haxe_ds__$StringMap_StringMapIterator {
	constructor(map,keys) {
		this.map = map;
		this.keys = keys;
		this.index = 0;
		this.count = keys.length;
	}
	hasNext() {
		return this.index < this.count;
	}
	next() {
		var _this = this.map;
		var key = this.keys[this.index++];
		if(__map_reserved[key] != null) {
			return _this.getReserved(key);
		} else {
			return _this.h[key];
		}
	}
}
haxe_ds__$StringMap_StringMapIterator.__name__ = true;
class haxe_ds_StringMap {
	constructor() {
		this.h = { };
	}
	setReserved(key,value) {
		if(this.rh == null) {
			this.rh = { };
		}
		this.rh["$" + key] = value;
	}
	getReserved(key) {
		if(this.rh == null) {
			return null;
		} else {
			return this.rh["$" + key];
		}
	}
	existsReserved(key) {
		if(this.rh == null) {
			return false;
		}
		return this.rh.hasOwnProperty("$" + key);
	}
	keys() {
		return HxOverrides.iter(this.arrayKeys());
	}
	arrayKeys() {
		var out = [];
		for( var key in this.h ) {
		if(this.h.hasOwnProperty(key)) {
			out.push(key);
		}
		}
		if(this.rh != null) {
			for( var key in this.rh ) {
			if(key.charCodeAt(0) == 36) {
				out.push(key.substr(1));
			}
			}
		}
		return out;
	}
	iterator() {
		return new haxe_ds__$StringMap_StringMapIterator(this,this.arrayKeys());
	}
}
haxe_ds_StringMap.__name__ = true;
class haxe_io_Bytes {
	constructor(data) {
		this.length = data.byteLength;
		this.b = new Uint8Array(data);
		this.b.bufferValue = data;
		data.hxBytes = this;
		data.bytes = this.b;
	}
}
haxe_io_Bytes.__name__ = true;
var haxe_io_Encoding = $hxEnums["haxe.io.Encoding"] = { __ename__ : true, __constructs__ : ["UTF8","RawNative"]
	,UTF8: {_hx_index:0,__enum__:"haxe.io.Encoding",toString:$estr}
	,RawNative: {_hx_index:1,__enum__:"haxe.io.Encoding",toString:$estr}
};
class haxe_io_Eof {
	constructor() {
	}
	toString() {
		return "Eof";
	}
}
haxe_io_Eof.__name__ = true;
var haxe_io_Error = $hxEnums["haxe.io.Error"] = { __ename__ : true, __constructs__ : ["Blocked","Overflow","OutsideBounds","Custom"]
	,Blocked: {_hx_index:0,__enum__:"haxe.io.Error",toString:$estr}
	,Overflow: {_hx_index:1,__enum__:"haxe.io.Error",toString:$estr}
	,OutsideBounds: {_hx_index:2,__enum__:"haxe.io.Error",toString:$estr}
	,Custom: ($_=function(e) { return {_hx_index:3,e:e,__enum__:"haxe.io.Error",toString:$estr}; },$_.__params__ = ["e"],$_)
};
class haxe_io_Path {
	constructor(path) {
		switch(path) {
		case ".":case "..":
			this.dir = path;
			this.file = "";
			return;
		}
		var c1 = path.lastIndexOf("/");
		var c2 = path.lastIndexOf("\\");
		if(c1 < c2) {
			this.dir = HxOverrides.substr(path,0,c2);
			path = HxOverrides.substr(path,c2 + 1,null);
			this.backslash = true;
		} else if(c2 < c1) {
			this.dir = HxOverrides.substr(path,0,c1);
			path = HxOverrides.substr(path,c1 + 1,null);
		} else {
			this.dir = null;
		}
		var cp = path.lastIndexOf(".");
		if(cp != -1) {
			this.ext = HxOverrides.substr(path,cp + 1,null);
			this.file = HxOverrides.substr(path,0,cp);
		} else {
			this.ext = null;
			this.file = path;
		}
	}
	toString() {
		return (this.dir == null ? "" : this.dir + (this.backslash ? "\\" : "/")) + this.file + (this.ext == null ? "" : "." + this.ext);
	}
	static withoutDirectory(path) {
		var s = new haxe_io_Path(path);
		s.dir = null;
		return s.toString();
	}
	static join(paths) {
		var _g = [];
		var _g1 = 0;
		var _g2 = paths;
		while(_g1 < _g2.length) {
			var v = _g2[_g1];
			++_g1;
			if(v != null && v != "") {
				_g.push(v);
			}
		}
		var paths1 = _g;
		if(paths1.length == 0) {
			return "";
		}
		var path = paths1[0];
		var _g3 = 1;
		var _g11 = paths1.length;
		while(_g3 < _g11) {
			var i = _g3++;
			path = haxe_io_Path.addTrailingSlash(path);
			path += paths1[i];
		}
		return haxe_io_Path.normalize(path);
	}
	static normalize(path) {
		var slash = "/";
		path = path.split("\\").join(slash);
		if(path == slash) {
			return slash;
		}
		var target = [];
		var _g = 0;
		var _g1 = path.split(slash);
		while(_g < _g1.length) {
			var token = _g1[_g];
			++_g;
			if(token == ".." && target.length > 0 && target[target.length - 1] != "..") {
				target.pop();
			} else if(token == "") {
				if(target.length > 0 || HxOverrides.cca(path,0) == 47) {
					target.push(token);
				}
			} else if(token != ".") {
				target.push(token);
			}
		}
		var tmp = target.join(slash);
		var acc_b = "";
		var colon = false;
		var slashes = false;
		var _g2_offset = 0;
		var _g2_s = tmp;
		while(_g2_offset < _g2_s.length) {
			var s = _g2_s;
			var index = _g2_offset++;
			var c = s.charCodeAt(index);
			if(c >= 55296 && c <= 56319) {
				c = c - 55232 << 10 | s.charCodeAt(index + 1) & 1023;
			}
			var c1 = c;
			if(c1 >= 65536) {
				++_g2_offset;
			}
			var c2 = c1;
			switch(c2) {
			case 47:
				if(!colon) {
					slashes = true;
				} else {
					var i = c2;
					colon = false;
					if(slashes) {
						acc_b += "/";
						slashes = false;
					}
					acc_b += String.fromCodePoint(i);
				}
				break;
			case 58:
				acc_b += ":";
				colon = true;
				break;
			default:
				var i1 = c2;
				colon = false;
				if(slashes) {
					acc_b += "/";
					slashes = false;
				}
				acc_b += String.fromCodePoint(i1);
			}
		}
		return acc_b;
	}
	static addTrailingSlash(path) {
		if(path.length == 0) {
			return "/";
		}
		var c1 = path.lastIndexOf("/");
		var c2 = path.lastIndexOf("\\");
		if(c1 < c2) {
			if(c2 != path.length - 1) {
				return path + "\\";
			} else {
				return path;
			}
		} else if(c1 != path.length - 1) {
			return path + "/";
		} else {
			return path;
		}
	}
}
haxe_io_Path.__name__ = true;
class js__$Boot_HaxeError extends Error {
	constructor(val) {
		super();
		this.val = val;
		if(Error.captureStackTrace) {
			Error.captureStackTrace(this,js__$Boot_HaxeError);
		}
	}
}
js__$Boot_HaxeError.__name__ = true;
class js_Boot {
	static __string_rec(o,s) {
		if(o == null) {
			return "null";
		}
		if(s.length >= 5) {
			return "<...>";
		}
		var t = typeof(o);
		if(t == "function" && (o.__name__ || o.__ename__)) {
			t = "object";
		}
		switch(t) {
		case "function":
			return "<function>";
		case "object":
			if(o.__enum__) {
				var e = $hxEnums[o.__enum__];
				var n = e.__constructs__[o._hx_index];
				var con = e[n];
				if(con.__params__) {
					s = s + "\t";
					return n + "(" + ((function($this) {
						var $r;
						var _g = [];
						{
							var _g1 = 0;
							var _g2 = con.__params__;
							while(true) {
								if(!(_g1 < _g2.length)) {
									break;
								}
								var p = _g2[_g1];
								_g1 = _g1 + 1;
								_g.push(js_Boot.__string_rec(o[p],s));
							}
						}
						$r = _g;
						return $r;
					}(this))).join(",") + ")";
				} else {
					return n;
				}
			}
			if(((o) instanceof Array)) {
				var str = "[";
				s += "\t";
				var _g3 = 0;
				var _g11 = o.length;
				while(_g3 < _g11) {
					var i = _g3++;
					str += (i > 0 ? "," : "") + js_Boot.__string_rec(o[i],s);
				}
				str += "]";
				return str;
			}
			var tostr;
			try {
				tostr = o.toString;
			} catch( e1 ) {
				var e2 = ((e1) instanceof js__$Boot_HaxeError) ? e1.val : e1;
				return "???";
			}
			if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
				var s2 = o.toString();
				if(s2 != "[object Object]") {
					return s2;
				}
			}
			var str1 = "{\n";
			s += "\t";
			var hasp = o.hasOwnProperty != null;
			var k = null;
			for( k in o ) {
			if(hasp && !o.hasOwnProperty(k)) {
				continue;
			}
			if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
				continue;
			}
			if(str1.length != 2) {
				str1 += ", \n";
			}
			str1 += s + k + " : " + js_Boot.__string_rec(o[k],s);
			}
			s = s.substring(1);
			str1 += "\n" + s + "}";
			return str1;
		case "string":
			return o;
		default:
			return String(o);
		}
	}
}
js_Boot.__name__ = true;
var js_node_ChildProcess = require("child_process");
var js_node_Fs = require("fs");
var js_node_Path = require("path");
var js_node_buffer_Buffer = require("buffer").Buffer;
var vscode_debugAdapter_Source = require("vscode-debugadapter").Source;
var vscode_debugAdapter_Scope = require("vscode-debugadapter").Scope;
var vscode_debugAdapter_Thread = require("vscode-debugadapter").Thread;
var vscode_debugAdapter_Breakpoint = require("vscode-debugadapter").Breakpoint;
var vscode_debugAdapter_StoppedEvent = require("vscode-debugadapter").StoppedEvent;
var vscode_debugAdapter_InitializedEvent = require("vscode-debugadapter").InitializedEvent;
var vscode_debugAdapter_TerminatedEvent = require("vscode-debugadapter").TerminatedEvent;
var vscode_debugAdapter_OutputEvent = require("vscode-debugadapter").OutputEvent;
var vscode_debugAdapter_Handles = require("vscode-debugadapter").Handles;
class vshaxeDebug__$CLIAdapter_DebuggerCommand {
	constructor(cmd,resultReceiver) {
		this.cmd = cmd;
		this.resultReceiver = resultReceiver;
		this.done = false;
	}
	execute(inputHandle) {
		inputHandle(this.cmd);
		if(this.resultReceiver == null) {
			this.setDone();
		}
	}
	processResult(lines) {
		if(this.resultReceiver(lines)) {
			this.setDone();
		}
	}
	setDone() {
		this.done = true;
	}
}
vshaxeDebug__$CLIAdapter_DebuggerCommand.__name__ = true;
class vshaxeDebug_CLIAdapter {
	constructor(config) {
		this.config = config;
		this.onPromptGot = config.onPromptGot;
		this.onError = config.onError;
		this.allOutputReceiver = config.allOutputReceiver;
		this.commandBuilder = config.commandBuilder;
		this.parser = config.parser;
		this.buffer = new js_node_buffer_Buffer(0);
	}
	start() {
		var env = { };
		var k = Sys.environment().keys();
		while(k.hasNext()) {
			var k1 = k.next();
			env[k1] = process.env[k1];
		}
		this.proc = js_node_ChildProcess.spawn(this.config.cmd,this.config.cmdParams,{ env : env});
		this.proc.stdout.on("data",$bind(this,this.onData));
		this.proc.stderr.on("data",function(buf) {
			haxe_Log.trace(buf.toString(),{ fileName : "src/vshaxeDebug/CLIAdapter.hx", lineNumber : 84, className : "vshaxeDebug.CLIAdapter", methodName : "start"});
		});
	}
	stop() {
		this.proc.kill("SIGINT");
	}
	queueSend(command,callback) {
		var cmd = new vshaxeDebug__$CLIAdapter_DebuggerCommand(command,callback);
		this.queueCommand(cmd);
	}
	queueCommand(command) {
		if(this.queueHead == null) {
			this.queueHead = this.queueTail = command;
		} else {
			this.queueTail.next = command;
			command.prev = this.queueTail;
			this.queueTail = command;
		}
		this.checkQueue();
	}
	send(command) {
		haxe_Log.trace("send to debugger cli: " + command + "\n",{ fileName : "src/vshaxeDebug/CLIAdapter.hx", lineNumber : 109, className : "vshaxeDebug.CLIAdapter", methodName : "send"});
		try {
			this.proc.stdin.write("" + command + "\n");
		} catch( e ) {
			var e1 = ((e) instanceof js__$Boot_HaxeError) ? e.val : e;
			if(((e1) instanceof Error)) {
				throw new js__$Boot_HaxeError(this.onError(e1));
			} else {
				throw e;
			}
		}
	}
	checkQueue() {
		if(this.currentCommand == null && this.queueHead != null) {
			this.currentCommand = this.queueHead;
			this.queueHead = this.currentCommand.next;
			this.executeCurrentCommand();
		}
	}
	executeCurrentCommand() {
		this.currentCommand.execute($bind(this,this.send));
		if(this.currentCommand.done) {
			this.removeCurrentCommand();
		}
	}
	removeCurrentCommand() {
		this.currentCommand = null;
		this.checkQueue();
	}
	removeCommand(command) {
		if(command == this.queueHead) {
			this.queueHead = command.next;
		}
		if(command == this.queueTail) {
			this.queueTail = command.prev;
		}
		if(command.prev != null) {
			command.prev.next = command.next;
		}
		if(command.next != null) {
			command.next.prev = command.prev;
		}
	}
	onData(buf) {
		var newLength = this.buffer.length + buf.length;
		this.buffer = js_node_buffer_Buffer.concat([this.buffer,buf],newLength);
		var rawInput = this.buffer.toString();
		if(this.parser.isPromptMatched(rawInput)) {
			var lines = this.parser.getLinesExceptPrompt(rawInput);
			lines.pop();
			this.buffer = new js_node_buffer_Buffer(0);
			if(this.currentCommand != null) {
				this.currentCommand.processResult(lines);
				if(this.currentCommand.done) {
					this.removeCurrentCommand();
				}
			}
			this.onPromptGot(lines);
		} else if(this.allOutputReceiver(rawInput)) {
			this.buffer = new js_node_buffer_Buffer(0);
		}
	}
}
vshaxeDebug_CLIAdapter.__name__ = true;
class vshaxeDebug_CommandsBatch {
	constructor($debugger,callback) {
		this.debugger = $debugger;
		this.callback = callback;
		this.waiting = this.got = 0;
	}
	add(command,callback) {
		if(callback != null) {
			this.waiting++;
		}
		this.debugger.queueSend(command,this.wrap(callback));
	}
	onResponse() {
		this.got++;
		this.checkIsDone();
	}
	checkIsDone() {
		if(this.waiting == this.got) {
			this.callback();
		}
	}
	wrap(callback) {
		var _gthis = this;
		var wrapper = callback;
		if(callback != null) {
			wrapper = function(output) {
				var result = callback(output);
				if(result) {
					_gthis.got++;
					_gthis.checkIsDone();
				}
				return result;
			};
		}
		return wrapper;
	}
}
vshaxeDebug_CommandsBatch.__name__ = true;
class vshaxeDebug_Context {
	constructor(protocol,$debugger) {
		this.protocol = protocol;
		this.debugger = $debugger;
		this.breakpoints = new haxe_ds_StringMap();
		this.fileNameToFullPathDict = new haxe_ds_StringMap();
		this.variableHandles = new vscode_debugAdapter_Handles();
		this.knownObjects = new haxe_ds_IntMap();
		this.debuggerState = vshaxeDebug_DebuggerState.WaitingGreeting;
	}
	onEvent(event) {
		this.debuggerState = vshaxeDebug_StateController.onEvent(this,event);
	}
	sendToOutput(output,category) {
		if(category == null) {
			category = "console";
		}
		this.protocol.sendEvent(new vscode_debugAdapter_OutputEvent(output + "\n",category));
	}
	sendError(response,message) {
		response.success = false;
		response.message = message;
		this.protocol.sendResponse(response);
	}
}
vshaxeDebug_Context.__name__ = true;
var vshaxeDebug_DebuggerState = $hxEnums["vshaxeDebug.DebuggerState"] = { __ename__ : true, __constructs__ : ["WaitingGreeting","Configuring","Running","Stopped"]
	,WaitingGreeting: {_hx_index:0,__enum__:"vshaxeDebug.DebuggerState",toString:$estr}
	,Configuring: {_hx_index:1,__enum__:"vshaxeDebug.DebuggerState",toString:$estr}
	,Running: {_hx_index:2,__enum__:"vshaxeDebug.DebuggerState",toString:$estr}
	,Stopped: ($_=function(frames,currentFrame) { return {_hx_index:3,frames:frames,currentFrame:currentFrame,__enum__:"vshaxeDebug.DebuggerState",toString:$estr}; },$_.__params__ = ["frames","currentFrame"],$_)
};
var vshaxeDebug_StateControlEvent = $hxEnums["vshaxeDebug.StateControlEvent"] = { __ename__ : true, __constructs__ : ["GreetingReceived","Continue","Stop","FrameUp","FrameDown","SetFrames"]
	,GreetingReceived: {_hx_index:0,__enum__:"vshaxeDebug.StateControlEvent",toString:$estr}
	,Continue: {_hx_index:1,__enum__:"vshaxeDebug.StateControlEvent",toString:$estr}
	,Stop: ($_=function(reason) { return {_hx_index:2,reason:reason,__enum__:"vshaxeDebug.StateControlEvent",toString:$estr}; },$_.__params__ = ["reason"],$_)
	,FrameUp: {_hx_index:3,__enum__:"vshaxeDebug.StateControlEvent",toString:$estr}
	,FrameDown: {_hx_index:4,__enum__:"vshaxeDebug.StateControlEvent",toString:$estr}
	,SetFrames: ($_=function(frames) { return {_hx_index:5,frames:frames,__enum__:"vshaxeDebug.StateControlEvent",toString:$estr}; },$_.__params__ = ["frames"],$_)
};
class vshaxeDebug_StateController {
	static onEvent(context,event) {
		var protocol = context.protocol;
		var currentState = context.debuggerState;
		switch(currentState._hx_index) {
		case 0:
			if(event._hx_index == 0) {
				protocol.sendEvent(new vscode_debugAdapter_InitializedEvent());
				return vshaxeDebug_DebuggerState.Configuring;
			} else {
				throw new js__$Boot_HaxeError("no transition: state: " + Std.string(currentState) + ", event: " + Std.string(event));
			}
			break;
		case 1:
			if(event._hx_index == 1) {
				return vshaxeDebug_DebuggerState.Running;
			} else {
				throw new js__$Boot_HaxeError("no transition: state: " + Std.string(currentState) + ", event: " + Std.string(event));
			}
			break;
		case 2:
			if(event._hx_index == 2) {
				var reason = event.reason;
				protocol.sendEvent(new vscode_debugAdapter_StoppedEvent(reason,1));
				return vshaxeDebug_DebuggerState.Stopped([],0);
			} else {
				throw new js__$Boot_HaxeError("no transition: state: " + Std.string(currentState) + ", event: " + Std.string(event));
			}
			break;
		case 3:
			var _g1 = currentState.currentFrame;
			var _g = currentState.frames;
			switch(event._hx_index) {
			case 1:
				return vshaxeDebug_DebuggerState.Running;
			case 3:
				var frames = _g;
				var currentFrame = _g1;
				if(currentFrame < frames.length - 1) {
					return vshaxeDebug_DebuggerState.Stopped(frames,currentFrame + 1);
				} else {
					throw new js__$Boot_HaxeError("no transition: state: " + Std.string(currentState) + ", event: " + Std.string(event));
				}
				break;
			case 4:
				var frames1 = _g;
				var currentFrame1 = _g1;
				if(currentFrame1 > 0) {
					return vshaxeDebug_DebuggerState.Stopped(frames1,currentFrame1 - 1);
				} else {
					throw new js__$Boot_HaxeError("no transition: state: " + Std.string(currentState) + ", event: " + Std.string(event));
				}
				break;
			case 5:
				var frames2 = _g;
				var currentFrame2 = _g1;
				var newFrames = event.frames;
				return vshaxeDebug_DebuggerState.Stopped(newFrames,0);
			default:
				throw new js__$Boot_HaxeError("no transition: state: " + Std.string(currentState) + ", event: " + Std.string(event));
			}
			break;
		}
	}
}
vshaxeDebug_StateController.__name__ = true;
class vshaxeDebug_PathUtils {
	normalizeDriveLetter(path) {
		var regex = new EReg("^([A-Z])(:[\\\\/].*)$","");
		if(regex.match(path)) {
			var drive = regex.matched(1);
			var tail = regex.matched(2);
			path = drive.toLowerCase() + tail;
		}
		return path;
	}
	static normalize(path) {
		path = StringTools.replace(path,"\\","/");
		if(new EReg("^[a-zA-Z]:/","").match(path)) {
			path = "/" + path;
		}
		path = js_node_Path.normalize(path);
		path = StringTools.replace(path,"\\","/");
		return path;
	}
	static isAbsolutePath(path) {
		var result = false;
		if(path != "") {
			if(path.charAt(0) == "/") {
				result = true;
			}
			if(new EReg("^[a-zA-Z]:[\\\\/]","").match(path)) {
				result = true;
			}
		}
		return result;
	}
	static isOnPath(program) {
		if(process.platform == "win32") {
			var WHERE = "C:\\Windows\\System32\\where.exe";
			try {
				if(js_node_Fs.existsSync(WHERE)) {
					js_node_ChildProcess.execSync("" + WHERE + " " + program);
				}
				return true;
			} catch( e ) {
				var e1 = ((e) instanceof js__$Boot_HaxeError) ? e.val : e;
			}
		} else {
			var WHICH = "/usr/bin/which";
			try {
				if(js_node_Fs.existsSync(WHICH)) {
					js_node_ChildProcess.execSync("" + WHICH + " '" + program + "'");
				}
				return true;
			} catch( e2 ) {
				var e3 = ((e2) instanceof js__$Boot_HaxeError) ? e2.val : e2;
			}
		}
		return false;
	}
}
vshaxeDebug_PathUtils.__name__ = true;
class vshaxeDebug_PlatformParameters {
	static getEndOfLineSign() {
		if(process.platform == "win32") {
			return "\r\n";
		} else {
			return "\n";
		}
	}
}
vshaxeDebug_PlatformParameters.__name__ = true;
var vshaxeDebug_VariableType = $hxEnums["vshaxeDebug.VariableType"] = { __ename__ : true, __constructs__ : ["Object","Simple"]
	,Object: ($_=function(id) { return {_hx_index:0,id:id,__enum__:"vshaxeDebug.VariableType",toString:$estr}; },$_.__params__ = ["id"],$_)
	,Simple: ($_=function(type) { return {_hx_index:1,type:type,__enum__:"vshaxeDebug.VariableType",toString:$estr}; },$_.__params__ = ["type"],$_)
};
var vshaxeDebug_ScopeType = $hxEnums["vshaxeDebug.ScopeType"] = { __ename__ : true, __constructs__ : ["Locals","Global","Closure","ObjectDetails"]
	,Locals: ($_=function(frameId,type) { return {_hx_index:0,frameId:frameId,type:type,__enum__:"vshaxeDebug.ScopeType",toString:$estr}; },$_.__params__ = ["frameId","type"],$_)
	,Global: ($_=function(frameId) { return {_hx_index:1,frameId:frameId,__enum__:"vshaxeDebug.ScopeType",toString:$estr}; },$_.__params__ = ["frameId"],$_)
	,Closure: ($_=function(frameId) { return {_hx_index:2,frameId:frameId,__enum__:"vshaxeDebug.ScopeType",toString:$estr}; },$_.__params__ = ["frameId"],$_)
	,ObjectDetails: ($_=function(id,name) { return {_hx_index:3,id:id,name:name,__enum__:"vshaxeDebug.ScopeType",toString:$estr}; },$_.__params__ = ["id","name"],$_)
};
class vshaxeDebug_commands_Evaluate extends vshaxeDebug_commands_BaseCommand {
	constructor(context,response,args) {
		super(context,response,args);
	}
	execute() {
		var preparedExpression = this.prepareExpression(this.args.expression);
		var command = this.cmd.evaluate(preparedExpression);
		this.debugger.queueSend(command,$bind(this,this.processResult));
	}
	processResult(lines) {
		var exprResult = this.parser.parseEvaluate(lines);
		this.response.body = { result : "could not be evaluated", variablesReference : 0};
		if(exprResult._hx_index == 0) {
			var v = exprResult.v;
			var _g = v.type;
			if(_g._hx_index == 0) {
				var id = _g.id;
				var vRef = this.context.variableHandles.create("object_" + id);
				this.response.body.variablesReference = vRef;
			}
			this.response.body.result = v.value;
		}
		this.context.protocol.sendResponse(this.response);
		return true;
	}
	prepareExpression(raw) {
		var dotStarts = new EReg("^\\..*","");
		var colonStarts = new EReg("^:.*","");
		if(dotStarts.match(raw)) {
			return "this" + raw;
		} else if(colonStarts.match(raw)) {
			return "";
		}
		return raw;
	}
}
vshaxeDebug_commands_Evaluate.__name__ = true;
class vshaxeDebug_commands_SetBreakpoints extends vshaxeDebug_commands_BaseCommand {
	constructor(context,response,args) {
		super(context,response,args);
	}
	execute() {
		this.result = [];
		if(this.args.source.name == null) {
			this.args.source.name = haxe_io_Path.withoutDirectory(this.args.source.path);
		}
		var source = new vscode_debugAdapter_Source(this.args.source.name,this.args.source.path);
		var pathKey = this.getKey(this.args.source.name);
		var _this = this.context.breakpoints;
		if(!(__map_reserved[pathKey] != null ? _this.existsReserved(pathKey) : _this.h.hasOwnProperty(pathKey))) {
			var _this1 = this.context.breakpoints;
			var value = [];
			if(__map_reserved[pathKey] != null) {
				_this1.setReserved(pathKey,value);
			} else {
				_this1.h[pathKey] = value;
			}
		}
		var _this2 = this.context.breakpoints;
		var breakpoints = __map_reserved[pathKey] != null ? _this2.getReserved(pathKey) : _this2.h[pathKey];
		var previouslySet = this.getAlreadySetMap(pathKey,this.context.breakpoints);
		var f = $bind(this,this.commandDoneCallback);
		var path = pathKey;
		var response = this.response;
		var batch = function() {
			f(path,response);
		};
		var batch1 = new vshaxeDebug_CommandsBatch(this.context.debugger,batch);
		if(this.context.debuggerState._hx_index == 2) {
			batch1.add(this.cmd.pause(),function(_) {
				return true;
			});
		}
		var _g1 = 0;
		var _g2 = this.args.breakpoints;
		while(_g1 < _g2.length) {
			var b = _g2[_g1];
			++_g1;
			if(previouslySet.h.hasOwnProperty(b.line)) {
				previouslySet.remove(b.line);
			} else {
				var breakpoint = new vscode_debugAdapter_Breakpoint(true,b.line,0,source);
				var cmd = this.cmd.addBreakpoint(this.args.source.name,this.args.source.path,b.line);
				batch1.add(cmd,(function(container,breakpoint1,f1) {
					return function(lines) {
						return f1[0](breakpoint1[0],container[0],lines);
					};
				})([breakpoints],[breakpoint],[$bind(this,this.onBreakpointAdded)]));
			}
		}
		var b1 = previouslySet.iterator();
		while(b1.hasNext()) {
			var b2 = b1.next();
			var cmd1 = this.cmd.removeBreakpoint(b2.source.name,b2.source.path,b2.line);
			batch1.add(cmd1,(function(container1,breakpoint2,f2) {
				return function(lines1) {
					return f2[0](breakpoint2[0],container1[0],lines1);
				};
			})([breakpoints],[b2],[$bind(this,this.onBreakpointRemoved)]));
		}
		if(this.context.debuggerState._hx_index == 2) {
			batch1.add(this.cmd.continueCommand());
		}
		batch1.checkIsDone();
	}
	onBreakpointAdded(breakpoint,container,lines) {
		var info = this.parser.parseAddBreakpoint(lines);
		if(info._hx_index == 0) {
			var bInfo = info.v;
			breakpoint.id = bInfo.id;
			breakpoint.source.name = bInfo.fileName;
			breakpoint.line = bInfo.line;
			container.push(breakpoint);
		} else {
			this.context.sendError(this.response,"AddBreakpoint FAILED: [ " + Std.string(lines) + " ]");
		}
		return true;
	}
	onBreakpointRemoved(breakpoint,container,lines) {
		HxOverrides.remove(container,breakpoint);
		return true;
	}
	commandDoneCallback(path,response) {
		var _this = this.context.breakpoints;
		var breakpoints = __map_reserved[path] != null ? _this.getReserved(path) : _this.h[path];
		var _g = [];
		var _g1 = 0;
		while(_g1 < breakpoints.length) {
			var b = breakpoints[_g1];
			++_g1;
			if(b.id > 0) {
				_g.push(b);
			}
		}
		var validated = _g;
		var _this1 = this.context.breakpoints;
		if(__map_reserved[path] != null) {
			_this1.setReserved(path,validated);
		} else {
			_this1.h[path] = validated;
		}
		response.success = true;
		response.body = { breakpoints : validated};
		this.context.protocol.sendResponse(response);
	}
	getAlreadySetMap(path,breakpoints) {
		var res = new haxe_ds_IntMap();
		if(__map_reserved[path] != null ? breakpoints.existsReserved(path) : breakpoints.h.hasOwnProperty(path)) {
			var addedForThisPath = __map_reserved[path] != null ? breakpoints.getReserved(path) : breakpoints.h[path];
			var _g = 0;
			while(_g < addedForThisPath.length) {
				var b = addedForThisPath[_g];
				++_g;
				res.h[b.line] = b;
			}
		}
		return res;
	}
	getKey(path) {
		var res = StringTools.replace(path,"\\","/");
		return res;
	}
}
vshaxeDebug_commands_SetBreakpoints.__name__ = true;
class vshaxeDebug_commands_StackTrace extends vshaxeDebug_commands_BaseCommand {
	constructor(context,response,args) {
		vshaxeDebug_commands_BaseCommand._hx_skip_constructor = true;
		super();
		vshaxeDebug_commands_BaseCommand._hx_skip_constructor = false;
		this._hx_constructor(context,response,args);
	}
	_hx_constructor(context,response,args) {
		this.frames = [];
		super._hx_constructor(context,response,args);
	}
	execute() {
		var batch = new vshaxeDebug_CommandsBatch(this.context.debugger,$bind(this,this.callback));
		if(Lambda.count(this.context.fileNameToFullPathDict) == 0) {
			batch.add(this.cmd.showFiles(),$bind(this,this.processShowFilesResult));
		}
		batch.add(this.cmd.stackTrace(),$bind(this,this.processStackTraceResult));
	}
	callback() {
		this.response.body = { stackFrames : this.frames};
		this.context.onEvent(vshaxeDebug_StateControlEvent.SetFrames(this.frames));
		this.context.protocol.sendResponse(this.response);
	}
	processShowFilesResult(lines) {
		var sources = this.parser.parseShowFiles(lines);
		var _g = 0;
		while(_g < sources.length) {
			var source = sources[_g];
			++_g;
			var key = source.name;
			var value = source.path;
			var _this = this.context.fileNameToFullPathDict;
			if(__map_reserved[key] != null) {
				_this.setReserved(key,value);
			} else {
				_this.h[key] = value;
			}
		}
		return true;
	}
	processStackTraceResult(lines) {
		var frames = this.parser.parseStackTrace(lines,$bind(this,this.pathProvider));
		this.response.body = { stackFrames : frames};
		this.context.onEvent(vshaxeDebug_StateControlEvent.SetFrames(frames));
		this.context.protocol.sendResponse(this.response);
		return true;
	}
	pathProvider(fileName) {
		haxe_Log.trace(fileName,{ fileName : "src/vshaxeDebug/commands/StackTrace.hx", lineNumber : 44, className : "vshaxeDebug.commands.StackTrace", methodName : "pathProvider"});
		var _this = this.context.fileNameToFullPathDict;
		haxe_Log.trace(__map_reserved[fileName] != null ? _this.existsReserved(fileName) : _this.h.hasOwnProperty(fileName),{ fileName : "src/vshaxeDebug/commands/StackTrace.hx", lineNumber : 45, className : "vshaxeDebug.commands.StackTrace", methodName : "pathProvider"});
		var _this1 = this.context.fileNameToFullPathDict;
		haxe_Log.trace(__map_reserved[fileName] != null ? _this1.getReserved(fileName) : _this1.h[fileName],{ fileName : "src/vshaxeDebug/commands/StackTrace.hx", lineNumber : 46, className : "vshaxeDebug.commands.StackTrace", methodName : "pathProvider"});
		var _this2 = this.context.fileNameToFullPathDict;
		if(__map_reserved[fileName] != null) {
			return _this2.getReserved(fileName);
		} else {
			return _this2.h[fileName];
		}
	}
}
vshaxeDebug_commands_StackTrace.__name__ = true;
class vshaxeDebug_commands_Variables extends vshaxeDebug_commands_BaseCommand {
	constructor(context,response,args) {
		super(context,response,args);
	}
	execute() {
		var id = this.args.variablesReference;
		var handleId = this.context.variableHandles.get(id);
		this.scope = this.getScopeOfHandle(handleId);
		this.result = [];
		var framesDiff = this.getFramesDiff(this.scope);
		var batch = new vshaxeDebug_CommandsBatch(this.context.debugger,$bind(this,this.callback));
		if(framesDiff != 0) {
			var _g = 0;
			var _g1 = Math.floor(Math.abs(framesDiff));
			while(_g < _g1) {
				var i = _g++;
				if(framesDiff < 0) {
					batch.add(this.cmd.frameUp());
				} else {
					batch.add(this.cmd.frameDown());
				}
			}
		}
		var _g2 = this.scope;
		switch(_g2._hx_index) {
		case 0:
			var _g6 = _g2.type;
			var frameId = _g2.frameId;
			var tmp = this.cmd.printLocalVariables();
			var f = $bind(this,this.processResult);
			var parser = ($_=this.parser,$bind($_,$_.parseLocalVariables));
			batch.add(tmp,function(lines) {
				return f(parser,lines);
			});
			var tmp1 = this.cmd.printFunctionArguments();
			var f1 = $bind(this,this.processResult);
			var parser1 = ($_=this.parser,$bind($_,$_.parseFunctionArguments));
			batch.add(tmp1,function(lines1) {
				return f1(parser1,lines1);
			});
			break;
		case 1:
			var frameId1 = _g2.frameId;
			var tmp2 = this.cmd.printGlobalVariables();
			var f2 = $bind(this,this.processResult);
			var parser2 = ($_=this.parser,$bind($_,$_.parseGlobalVariables));
			batch.add(tmp2,function(lines2) {
				return f2(parser2,lines2);
			});
			break;
		case 2:
			var fameId = _g2.frameId;
			var tmp3 = this.cmd.printMembers();
			var f3 = $bind(this,this.processResult);
			var parser3 = ($_=this.parser,$bind($_,$_.parseMembers));
			batch.add(tmp3,function(lines3) {
				return f3(parser3,lines3);
			});
			break;
		case 3:
			var _g21 = _g2.id;
			var name = _g2.name;
			var tmp4 = this.cmd.printObjectProperties(name);
			var f4 = $bind(this,this.processResult);
			var parser4 = ($_=this.parser,$bind($_,$_.parseObjectProperties));
			var parentName = name;
			batch.add(tmp4,function(lines4) {
				return f4(parser4,lines4,parentName);
			});
			break;
		}
	}
	callback() {
		this.response.body = { variables : this.result};
		this.context.protocol.sendResponse(this.response);
	}
	processResult(parser,lines,parentName) {
		if(parentName == null) {
			parentName = "";
		}
		var variableItems = parser(lines);
		var _g = 0;
		while(_g < variableItems.length) {
			var item = variableItems[_g];
			++_g;
			var vRef = 0;
			var varType;
			var _g1 = item.type;
			switch(_g1._hx_index) {
			case 0:
				var id = _g1.id;
				vRef = this.context.variableHandles.create("object_" + id);
				var this1 = this.context.knownObjects;
				var value = this.joinWithParent(item.name,parentName);
				this1.h[id] = value;
				varType = "Object";
				break;
			case 1:
				var type = _g1.type;
				varType = type;
				break;
			}
			this.result.push({ name : item.name, type : varType, value : item.value, variablesReference : vRef});
		}
		return true;
	}
	getScopeOfHandle(handleId) {
		var parts = handleId.split("_");
		var prefix = parts[0];
		switch(prefix) {
		case "globals":
			return vshaxeDebug_ScopeType.Global(Std.parseInt(parts[1]));
		case "locals":
			return vshaxeDebug_ScopeType.Locals(Std.parseInt(parts[1]),1);
		case "members":
			return vshaxeDebug_ScopeType.Closure(Std.parseInt(parts[1]));
		case "object":
			var objectId = Std.parseInt(parts[1]);
			var objectName = this.context.knownObjects.h[objectId];
			return vshaxeDebug_ScopeType.ObjectDetails(objectId,objectName);
		default:
			throw new js__$Boot_HaxeError("could not recognize");
		}
	}
	getFramesDiff(scope) {
		var frameId;
		switch(scope._hx_index) {
		case 0:
			var _g3 = scope.type;
			var frameId1 = scope.frameId;
			frameId = haxe_ds_Option.Some(frameId1);
			break;
		case 1:
			var frameId2 = scope.frameId;
			frameId = haxe_ds_Option.Some(frameId2);
			break;
		case 2:
			var frameId3 = scope.frameId;
			frameId = haxe_ds_Option.Some(frameId3);
			break;
		default:
			frameId = haxe_ds_Option.None;
		}
		var currentFrame;
		var _g4 = this.context.debuggerState;
		if(_g4._hx_index == 3) {
			var currentFrame1 = _g4.currentFrame;
			var frames = _g4.frames;
			currentFrame = haxe_ds_Option.Some(currentFrame1);
		} else {
			currentFrame = haxe_ds_Option.None;
		}
		if(frameId._hx_index == 0) {
			if(currentFrame._hx_index == 0) {
				var requestedFrame = frameId.v;
				var currentFrame2 = currentFrame.v;
				return currentFrame2 - requestedFrame;
			} else {
				return 0;
			}
		} else {
			return 0;
		}
	}
	joinWithParent(name,parentName) {
		if(parentName == "") {
			return name;
		}
		if(Std.parseInt(name) != null) {
			return "" + parentName + "[" + name + "]";
		} else {
			return "" + parentName + "." + name;
		}
	}
}
vshaxeDebug_commands_Variables.__name__ = true;
function $getIterator(o) { if( o instanceof Array ) return HxOverrides.iter(o); else return o.iterator(); }
function $bind(o,m) { if( m == null ) return null; if( m.__id__ == null ) m.__id__ = $global.$haxeUID++; var f; if( o.hx__closures__ == null ) o.hx__closures__ = {}; else f = o.hx__closures__[m.__id__]; if( f == null ) { f = m.bind(o); o.hx__closures__[m.__id__] = f; } return f; }
if(typeof $global.$haxeUID == "undefined") $global.$haxeUID = 0;
if( String.fromCodePoint == null ) String.fromCodePoint = function(c) { return c < 0x10000 ? String.fromCharCode(c) : String.fromCharCode((c>>10)+0xD7C0)+String.fromCharCode((c&0x3FF)+0xDC00); }
String.__name__ = true;
Array.__name__ = true;
var __map_reserved = {};
Object.defineProperty(js__$Boot_HaxeError.prototype,"message",{ get : function() {
	return String(this.val);
}});
js_Boot.__toStr = ({ }).toString;
vshaxeDebug_commands_BaseCommand._hx_skip_constructor = false;
fdbAdapter_Adapter.main();
})(typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this);
